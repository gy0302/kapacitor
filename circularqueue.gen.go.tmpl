//lint:file-ignore U1000 this is generated code
package kapacitor

{{with $types := .}}{{range $k := $types}}

// CircularQueue defines a circular queue, always use the contructor to create one.
type {{ $k }}CircularQueue struct {
	data     []{{ $k }}
	head     int
	tail     int
	l        int
	oldHead  int
}


// {{ if eq (substr 0 1 $k ) (substr 0 1 $k | upper) -}} New {{- else -}} new {{- end -}}
{{- substr 0 1 $k | upper -}}{{- substr 1 (len $k) $k -}} constructs a Circular Queue
// with a given buffer buf.  It is ok for buf to be nil.
func {{ if eq (substr 0 1 $k ) (substr 0 1 $k | upper) -}} New {{- else -}} new {{- end -}}
{{- substr 0 1 $k | upper -}}{{- substr 1 (len $k) $k -}} CircularQueue(buf ...{{ $k }}) *{{ $k }}CircularQueue {
    return &{{ $k }}CircularQueue{
        data: buf,
        head: 0,
        tail: len(buf),
        l :   len(buf),
        oldHead: -1,  // -1 means there is no oldHead
    }
}

func (q * {{- $k -}} CircularQueue) Enqueue(v ...{{ $k }}) bool {
    // if full we must grow and insert together. This is an expensive op
    switch{
        case cap(q.data) >= q.l+len(v): // no need to grow
            q.data = q.data[:cap(q.data)] //expand to ful size to keep copy happy
            n := copy(q.data[q.tail:] , v) // copy the data after the tail till the end of the buffer
            if n < len(v){
                copy(q.data[:q.head], v[n:]) // copy the data from what we just copied till the head
            }
            q.tail += n
            q.data = q.data[:q.tail] // resize q.data to where it should be
        case cap(q.data) < len(v)+q.l: // we need to grow
            if q.tail > q.head { // where the current buffer is filled with continuous data
                // we need to slice up v by how much we need to grow added to any free space left at the end of the buffer
                // which is (len(v)+q.l-cap(q.data))+(cap(q.data)- q.tail)
                endL := len(v)+q.l-q.tail
                q.data = append(q.data[:0], append(v[endL:], append(q.data[q.head : q.tail], v[:endL]...)...)...)
                q.tail += endL
                break
            }
            // when the current buffer is broken up (so the new stuff is continuous)
            q.data = append(q.data[:q.tail], append(v, q.data[q.head:]...)...)
            q.tail += len(v)
    }
	q.l += len(v)

	// wrap tail
	if q.tail == len(q.data)+1{
	    q.tail = 0
	    return true
	}
	return true
}

// Next moves the head forward.
func (q *{{ $k }}CircularQueue) Next() bool {

    // zero the old q.head to prevent leaking of sub fields.
    var fill {{ $k }}
    if q.oldHead >= 0{
        q.data[q.oldHead] = fill
    }
    q.oldHead = q.head

    // check for empty
    if q.head == q.tail{
        q.oldHead = -1
        return false
    }
    q.l--
    q.head++

    // wrap head if needed
    if q.head == len(q.data)+1{
        q.head = 0
    }


    return true
}

// Dequeue accesses the item in the queue.  If Next has not been called, it will panic.
func (q *{{ $k }}CircularQueue) Val() {{ $k }} {
    return q.data[q.head-1]
}

// Peek looks at the queue without dequeueing.
func (q *{{ $k }}CircularQueue) Peek(i int) ({{ $k }}, bool) {

    if i > q.l-1{
        var x {{$k}}
        return x, false
    }
        p := q.head+i
        if p >= len(q.data) {
            p-=len(q.data)
        }
        return q.data[p], true
}


// Len returns the current number of items in the queue.
func (q *{{ $k }}CircularQueue) Len() int {
    return q.l
}

{{end}}
{{end}}
